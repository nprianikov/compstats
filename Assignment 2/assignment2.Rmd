---
title: "KEN4258: Computational Statistics"
subtitle: "Assignment 2"
author: 
  - Aurélien Bertrand
  - Bart van Gool
  - Gaspar Kuper
  - Ignacio Cadarso Quevedo
  - Nikola Prianikov
date: "March 2024"
output: pdf_document
classoption: a4paper
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE, 
  message = FALSE, 
  fig.width = 5, 
  fig.height = 4, 
  out.width = "50%", 
  fig.align = "center"
)
```

# Assignment 2

Link to our GitHub repository: <https://github.com/nprianikov/compstats>

## 1) Reproduce Figure 1 from [(Candès et al. 2018)](https://arxiv.org/abs/1610.02351).

```{r}
library(tibble)

set.seed(101)

n <- 500
p <- 200
n_sim <- 1000 # TODO: not showing anything with 10000

# Generate X as a single AR(1) time-series of size p
generate_AR1 <- function(n, p) {
  X <- replicate(p, arima.sim(n=n, list(0.5)))
  return(X)
}

# Function to generate responses, fit a logistic regression model and return individual p-values
generate_responses <- function(n, p, prob = NULL) {
  X <- generate_AR1(n=n, p=p)
  if (is.null(prob)) {
    prob <- plogis(0.08 * rowSums(X[, 2:22]))
  }
  Y <- rbinom(n, 1, prob)
  
  fit <- glm(Y ~ X, family = binomial(link="logit"))
  
  p_values <- summary(fit)$coef[, "Pr(>|z|)"][-1] # Exclude intercept
  return(p_values)
}

# Combine the lists into a single tibble
df_plot <- tibble(
  p_values_1 = c(replicate(n_sim, generate_responses(n=n, p=p, prob=0.5))),
  p_values_2 = c(replicate(n_sim, generate_responses(n=n, p=p)))
)
```

```{r, echo=FALSE, fig.width=10, fig.height=2}
library(ggplot2)
library(cowplot)

# Create histograms for each set of p-values
histogram_1 <- ggplot(df_plot, aes(x=p_values_1)) + 
  geom_histogram(color="red", fill="blue", bins=20, boundary=0) +
  labs(x="P-values", y="count", title="Global Null, AR(1) Design") +
  theme(plot.title=element_text(hjust=0, face="bold")) +
  scale_x_continuous(limits=c(0, 1)) +
  scale_y_continuous(limits=c(0, 2000))

histogram_2 <- ggplot(df_plot, aes(x=p_values_2)) + 
  geom_histogram(color="red", fill="blue", bins=20, boundary=0) +
  labs(x="P-values", y="count", title="20 Nonzero Coefficients, AR(1) Design") +
  theme(plot.title=element_text(hjust=0, face="bold")) +
  scale_x_continuous(limits=c(0, 1)) +
  scale_y_continuous(limits=c(0, 2000))

# Arrange the plots side by side
combined_plots <- plot_grid(
  histogram_1, histogram_2, nrow=1, ncol=2, shareY=TRUE, shareX=TRUE
)

# Display the combined plots
print(combined_plots)
```

## 2) What is the problem that Figure 1 tries to illustrate?

## 3) Propose a solution to address the problem.

```{r}
# draw a new sample from the conditional distribution of Xj | X-j using a random number generator
# Not sure if this is the correct way to sample
simulate_Xj_given_Xj <- function(X, j) {
  Xj <- X[, j] 
  X_minus_j <- X[, -j, drop = FALSE]
  
  # Fit a model to predict Xj from the rest of the data
  model <- glm(Xj ~ X_minus_j - 1, family = "gaussian") 
  predicted_Xj <- predict(model, newdata = list(X_minus_j = X_minus_j))
  
  residuals_sd <- sd(resid(model))
  # Generate new samples for Xj with added randomness
  new_Xj_samples <- predicted_Xj + rnorm(length(predicted_Xj), mean = 0, sd = residuals_sd)
  
  return(new_Xj_samples)
}



# Feature importance statistic function to test whether Xj and Y are conditionally independent.
compute_Tj <- function(X, y) {
  fit <- glm(y ~ X, family = binomial(link="logit"))
  coef <- coef(fit)
  return(abs(coef))
}




# Conditional Randomization Test for a specific j
conditional_randomization_test <- function(X, y, j, K = 200) {
  original_Tj <- compute_Tj(X, y)[j]
  greater_count <- 0
  
  for (k in 1:K) {
    # Create a new data matrix by simulating the jth column and keeping the remaining columns the same
    X_simulated <- X
    X_simulated[, j] <- simulate_Xj_given_Xj(X, j)
    
    # Compute Tj for the simulated data
    simulated_Tj <- compute_Tj(X_simulated, y)[j]
    
    # Increment count if simulated Tj is greater than or equal to the original Tj
    if (simulated_Tj >= original_Tj) {
      greater_count <- greater_count + 1
    }
  }
  
  # Calculate p-value
  p_value <- (1 + greater_count) / (K + 1)
  return(p_value)
}

# Conditional Randomization Test for entire matrix X
conditional_randomization_test_all <- function(X, y, K = 200) {
  p_values <- numeric(ncol(X))

  for (j in 1:ncol(X)) {
    p_values[j] <- conditional_randomization_test(X, y, j, K)
  }
  
  return(p_values)
}

X <- generate_AR1(n=n, p=p)
Y <- rbinom(n, 1, 0.5)
p_values <- conditional_randomization_test_all(X, Y)
print(p_values)
```

## 4) Show that your solution fixes the problem.

## 5) Find a real dataset and apply your method.
