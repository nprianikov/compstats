---
title: "KEN4258: Computational Statistics"
subtitle: "Assignment 2"
author: 
  - Aurélien Bertrand
  - Bart van Gool
  - Gaspar Kuper
  - Ignacio Cadarso Quevedo
  - Nikola Prianikov
date: "March 2024"
output: pdf_document
classoption: a4paper
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE, 
  message = FALSE, 
  fig.width = 5, 
  fig.height = 4, 
  out.width = "50%", 
  fig.align = "center"
)
```

# Assignment 2

Link to our GitHub repository: <https://github.com/nprianikov/compstats>

## 1) Reproduce Figure 1 from [(Candès et al. 2018)](https://arxiv.org/abs/1610.02351).

```{r}

get_pvalues <- function(p, n, ar_coefficient, prob, logit_coefficient){
  
  # Simulate AR(1) processes for each predictor
  X <- matrix(nrow = n, ncol = p)
  for (i in 1:p) {
    X[, i] <- arima.sim(n = n, model = list(ar = ar_coefficient))
  }

  # SIMULATION 1
  Y1 <- rbinom(n, size = 1, prob = prob)
  

  # Convert X matrix to a data frame for glm
  X_df <- as.data.frame(X)
  
  # Add Y to the data frame
  X_df$Y1 <- Y1
  
  # Fit a GLM model with all predictors
  glm_model_1 <- glm(Y1 ~ ., data = X_df, family = binomial)
  
  # Summary of the model to get p-values
  p_values1 <- coef(summary(glm_model_1))[, "Pr(>|z|)"]
  p_values1 <- p_values[-1]  # Exclude the intercept (assuming it's the first coefficient)
  
  
  # SIMULATION 2
  # Initialize Y2
  Y2 <- numeric(n)

  # Calculate probabilities and simulate Y for each observation
  for (i in 1:n) {
    # Calculate the sum of predictors X2 to X21 for each observation
    predictors_sum <- sum(X[i, 2:21])
    # Calculate the logistic probability
    prob_i <- plogis(logit_coefficient * predictors_sum)
    # Simulate Y based on the calculated probability
    Y2[i] <- rbinom(1, size = 1, prob = prob_i)
  }
  # Add Y_logistic to the data frame
  X_df$Y2 <- Y2
  
  # Fit a GLM model with all predictors for the logistic simulation
  glm_model_2 <- glm(Y2 ~ ., data = X_df, family = binomial(link = "logit"))
  
  # Summary of the model to get p-values
  p_values2 <- coef(summary(glm_model_2))[, "Pr(>|z|)"]
  p_values2 <- p_values2[-1]  # Exclude the intercept (assuming it's the first coefficient)
  

  return(list(p1 = p_values1, p2 = p_values2))
}

```

```{r}

# Parameters
p <- 200 # Number of predictors
n <- 500 # Number of observations for Y
ar_coefficient <- 0.5
prob <- 0.5
logit_coefficient <- 0.08
replications <- 10
set.seed(100)
results <- replicate(replications, get_pvalues(p, n, ar_coefficient, prob, logit_coefficient), simplify = FALSE)

# Aggregate the p-values for each simulation
p_values1 <- unlist(lapply(results, function(x) x$p1))
p_values2 <- unlist(lapply(results, function(x) x$p2))


hist(p_values1, breaks=25, main="Histogram of P-Values", xlab="P-Value", ylab="Frequency",
     col="blue", border="black")


hist(p_values2, breaks=25, main="Histogram of P-Values", xlab="P-Value", ylab="Frequency",
     col="blue", border="black")
```



## 2) What is the problem that Figure 1 tries to illustrate?

## 3) Propose a solution to address the problem.

## 4) Show that your solution fixes the problem.

## 5) Find a real dataset and apply your method.
